---
title: "G1"
date: 2024-04-28
categories: [ 垃圾回收器 ]
tags: [ JVM,垃圾回收器,G1 ]
---

# G1
- G1(Garbage-First)，适用于低延迟和高吞吐量的场景
- 它的设计目标是尽可能避免停顿时间过长
- 它将堆内存分为多个区，并优先回收垃圾量较多的区域

# G1 特点
- 分区设计
  - G1将堆内存划分为多个小块（Region），每个Region的大小可以动态调整，通常在2MB到32MB之间。堆分为两个主要部分：年轻代（Young Generation）和老年代（Old Generation）。这些Region可以包含年轻代、老年代，甚至是废弃对象的存储区（Humongous objects）。
- 优先回收垃圾量较多的区域
  - G1在执行垃圾回收时，首先会选择垃圾最多的Region进行回收，这样可以更高效地回收内存，减少停顿时间。
- 可预测的停顿时间
  - 可配置最大停顿时间(`-XX:MaxGCPauseMillis`)
- 渐进式回收
  - 它可以在多个回收周期内渐进地回收垃圾，而不是在单次回收时回收整个堆，避免长时间的停顿

# 回收过程
1.初始标记
- 这个过程是STW（Stop-The-World）的，但通常耗时非常短。它标记出从GC Roots直接可达的对象，作为后续垃圾收集的基础。
2.并发标记
- 在初始标记完成后，G1 GC会进入并发标记阶段。这个阶段与应用程序线程并发执行，通过递归地追踪所有可达的对象，并将它们标记为存活。这个过程是并发的，因此不会阻塞应用程序的执行。
3.最终标记
- 为了处理在并发标记过程中新产生的对象引用关系，G1 GC会执行一次短暂的STW的最终标记。这个阶段确保所有在并发标记阶段漏掉的对象都被正确标记
4.筛选回收
- 在这个阶段，G1 GC会根据每个Region的垃圾堆积情况和回收价值进行排序，并选择性地回收部分Region中的垃圾对象。回收过程包括将存活的对象从一个Region复制或移动到另一个Region，并更新相关的引用。这个过程也是并发的，旨在最大限度地减少停顿时间。同时，这个阶段可能会涉及到对象的整理和压缩，以减少内存碎片。


# 并发标记的写屏障策略
SATB(Snapshot-At-The-Beginning)
  - 认为对象图在标记开始时的快照是准确的
  - 原理：
    - 在并发标记时假设对象图不会发生变化，任何在这个“快照”后发生的引用删除都会被记录并处理，以确保不会误会收仍然可达的对象
  - 写操作屏障
    - 如果在标记过程中将一个对象从 A 改成 B,那么 GC 会把旧值 A 记录下来（本地队列，最后汇聚到全局队列中），确保 A 也会被扫描
  - 举例
    - A 引用 B，改成了 A 引用 C，那么 B 会怎样？
      - B 依然会被标记，不会被错误回收
      - 即使 A 不再指向 B，只要 B 是在标记开始时被引用过的，SATB 写屏障会确保 B 被标记，进而被认为是“活着的”。

# RSet 记忆集需要记录哪些引用
1. Region内部的引用关系
   - 因为是内部的，不管是做新生代回收、老年代回收、还是FGC回收，在GC Roots标记的过程中，是一定可以追踪到这种引用关系的。因为被选中的Region分区，它里面的所有对象一定都会被遍历到。所以Region内部的引用关系，不需要记录；

2. 新生代和新生代间的引用关系
   - 这个和Region内部的原理是一样的。新生代GC时肯定可以全部遍历一遍，所以也不需要记录，老年代GC又和这种新生代之间的引用关系没什么相关联的地方。

3. 新生代到老年代的引用关系
   - 假如要进行新生代的回收，因为是新生代引用了老年代对象，所以即便遍历到了，新生代GC也不会去处理老年代的对象，并且这种引用关系在新生代回收过程中，也一定会被遍历到。
   - 假如要进行老年代的回收，老年代Region需要知道谁引用了自己，不然可能会出错。但是我们知道GC回收过程是没有老年代的单独回收的，所以如果要回收老年代，肯定会带着一次新生代回收或者直接FGC的，所以也不需要记录。

4. 老年代到新生代的引用关系
   - 需要记录
   - 卡表主要用于跟踪老年代对新生代的引用

5. 老年代到老年代的引用关系
   - 假如进入到Mixed回收阶段，那么此时只会选择老年代的部分Region来回收。由于只需选择部分Region进行回收，所以其他Region尽量就不要去遍历。因此需要记录老年代到老年代的引用，避免Mixed回收时遍历老年代。
   - 每个 region 都有一个 RSet
