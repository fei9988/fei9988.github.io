---
title: "卡表"
date: 2024-04-28
categories: [ 垃圾回收器 ]
tags: [ JVM,垃圾回收器,卡表 ]
---

# Java 中的卡表（Card Table）机制详解

## 一、为什么需要卡表？

在 JVM 的分代垃圾收集中（如 G1、CMS 等），存在以下典型场景：

- 年轻代对象引用老年代对象
- 老年代对象引用年轻代对象（**跨代引用**）

在 **Minor GC** 时，如果老年代中对象引用了年轻代对象，GC
需要扫描这些引用。但直接扫描整个老年代代价非常高，因此需要一种机制来快速定位这些引用 —— **卡表就应运而生
**。

---

## 二、卡表是什么？

卡表（**Card Table**）是一张用于记录“堆内存中哪些区域可能被写入过引用”的表。JVM 会将整个堆划分为许多 *
*固定大小（如 512 字节）** 的小块（卡片 Card），为每个卡片分配一个字节或位来表示是否被修改。

它与**写屏障（Write Barrier）**配合使用。

---

## 三、卡表的工作机制

### 1. 堆划分为卡片

整个 Java 堆被划分为大小固定的区域，每个区域称为一个“卡片”，通常为 **512 字节**。

### 2. 写屏障 + 卡表更新

当程序执行引用赋值语句，例如：

```java
objA.field =objB;
```

如果 `objA` 是老年代对象，`objB` 是年轻代对象，写屏障会将 `objA` 所在的卡片标记为 **“脏”**（dirty）。

### 3. GC 使用卡表

当发生 Minor GC 时，JVM 会根据卡表，只扫描标记为“脏”的卡片对应的内存区域，而不是整个老年代。这样大大提高了
GC 效率。

---

## 四、卡表在 G1 GC 中的角色

- G1 GC 使用了更进一步的机制：**Remembered Set（记忆集合）**
- 每个 Region 都有自己的 Remembered Set，用来记录哪些其他 Region 的对象引用了它
- **卡表是 Remembered Set 的底层数据结构之一**，结合写屏障实现动态更新

---

## 五、图示理解（文字版）

```
Heap（内存）:
|----------------|----------------|----------------|----------------|
|     卡片0      |     卡片1      |     卡片2      |     卡片3      |
|  512字节内存块  |  512字节内存块  |  512字节内存块  |  512字节内存块  |

Card Table（卡表）:
|------|------|------|------|
| Clean| Dirty| Clean| Dirty|  <-- 表示是否被引用写入修改

GC 时只扫描卡片1 和 卡片3
```

---

## 六、总结表格

| 项目       | 内容                                     |
|----------|----------------------------------------|
| 名称       | 卡表（Card Table）                         |
| 作用       | 跟踪老年代对象是否引用了年轻代对象                      |
| 搭配机制     | 写屏障（Write Barrier）                     |
| 粒度       | 通常为每 512 字节内存一个卡片                      |
| 使用方式     | Minor GC 时扫描标记为脏的卡片区域                  |
| 在 G1 中角色 | 是 Remembered Set 的基础结构，用于追踪跨 Region 引用 |

---

## 七、总结一句话

> **卡表是 JVM 中追踪跨代引用更新的高效手段，通过写屏障动态标记，配合 GC 精确回收，减少无谓扫描，提高性能。
**



