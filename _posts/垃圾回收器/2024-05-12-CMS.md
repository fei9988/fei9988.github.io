---
title: "CMS"
date: 2024-04-28
categories: [ 垃圾回收器 ]
tags: [ JVM,垃圾回收器,CMS ]
---

# CMS
- CMS 是 HotSpot 虚拟机中的一种老年带垃圾回收器，它有年轻代的 ParNew 垃圾回收期配合使用。
- 它的大部分回收操作与用户线程并发执行，减少停顿。

# CMS 的执行过程
1.初始标记（STW）
  - 只标记 GC Root 直接可达的对象
    - 方法区中常量引用的对象
    - 方法区中静态变量引用的对象
    - 虚拟机栈中的引用对象（栈帧中的本地变量表）
    - 本地方法栈中的引用对象
2.并发标记
    - 标记出所有可到达的对象
3.重新标记 (STW)
    - 重新解析出在并发标记阶段发生变化的对象，进行重新标注
4.并发清除
    - 根据标记结果，清除掉不可达的对象

# 重新标记依据什么？
- 依据写屏障
  - 写屏障是一种在垃圾回收机制中用于拦截对象引用关系修改操作的技术手段。当应用程序执行会改变对象引用关系的指令时，写屏障就会介入，在这个修改动作前后执行一些额外的代码逻辑，目的是为了辅助垃圾回收期更好地追踪对象的存活状态变化，确保标记状态的准确性
- 根据写屏障记录的变动，重新扫描一次，重新标记

# CMS 的缺点
- 会产生内存碎片
  - CMS使用的是标记-清除算法，清理后会产生很多不连续的内存空间

# CMS 中的卡表
## 作用
- CMS 的年轻代使用 ParNew GC，老年代使用 CMS GC。为了避免 每次 Minor GC 都扫描整个老年代，CMS 使用卡表实现 记忆集（Remembered Set）
- 卡表记录老年代中引用了新生代对象的内存区域
- CMS 利用卡表标记哪些卡片区域中的对象“可能”有引用新生代的对象。 
  - 当发生引用写操作时，卡表被更新； 
  - GC 时只扫描标记为“脏”的卡片（dirty cards）。
- 卡表本身是存储在 老年代 中的，它的作用是记录老年代中哪些区域的对象引用了新生代的对象。新生代的对象本身不包含卡表，而是通过 写屏障 来更新老年代的卡表，以便在 Minor GC 时只扫描涉及的“脏卡”，提高效率。

# 并发标记的写屏障策略    
增量更新
- 假设对象图在标记结束时是准确的
  - 任何在标记过程中新增的引用，GC 都会记录并确保新的引用也被标记。
- 写屏障操作：
  如果你在标记过程中将某字段从 A 改为 B，那么 GC 会将“新值 B”加入标记队列，确保 B 也被标记。
- 举例
  - A 引用 B，改为引用 C
  - 记录新的引用关系A->C

